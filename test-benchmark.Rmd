---
title: "Benchmark"
author: "John Tipton"
date: "2/22/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
```

```{r, results='hide', echo=FALSE}
dat <- readRDS("../benchmark-data/Pollen/Whitmore/whitmore_pollen.rds")
# str(dat)
y <- as.matrix(dat[[1]])
## drop site name
sitenames <- y[, 1]
y <- y[, -1]
names <- colnames(y)
y <- matrix(as.numeric(y), dim(y))
colnames(y) <- names
rownames(y) <- sitenames
# str(y)
## Set NAs to 0
y[is.na(y)] <- 0
```

```{r}
clim <- read.csv("../benchmark-data/Climate/Worldclim/whitmore_worldclim_10min.csv")
# str(clim)
X <- clim$Tann
names(X) <- as.character(clim$ID2)
# all.equal(rownames(y), names(X))
## get same values
X <- X[match(rownames(y), names(X))]
y <- y[match(names(X), rownames(y)), ]
# all.equal(rownames(y), names(X))

## remove NA climate 
na_idx <- which(is.na(X))
y <- y[-na_idx, ]
X <- X[-na_idx]
# ## check if any NAs
# sum(is.na(y))
# sum(is.na(X))
# ## make sure colnames are still ok
# all.equal(rownames(y), names(X))
```


```{r}
library(Methods)
library(magrittr)
library(ggplot2)

## subset the rare species
## N = 2314827
N <- sum(y)

## remove species that are less than 0.5% of the total
subset_count <- 0.005 * sum(y)
subset_idx <- apply(y, 2, sum) < subset_count

## removing 109252 counts and 74 species
sum(y[, subset_idx])
y <- y[, !subset_idx]

## still have over 95% of all pollen counts
sum(y) / N

##
N <- sum(y)


## subset for testing
y=y[1:501, ]
X=X[1:501]

model_name="WA"
WA=make_CV(y=y, X=X, model_name=model_name, kfold=2)

model_name="MAT"
MAT=make_CV(y=y, X=X, model_name=model_name, kfold=2)

model_name="MLRC"
MLRC=make_CV(y=y, X=X, model_name=model_name, kfold=2)

model_name="RF"
RF=make_CV(y=y, X=X, model_name=model_name, kfold=2)

model_name="BUMMER"
## note: use vb=TRUE for large datasets, vb=FALSE is more accurate
BUMMER=make_CV(y=y, X=X, model_name=model_name, kfold=2, 
               n_samples=500, n_grid=500,
               algorithm="fullrank",
               pooled=TRUE, vb=FALSE)

## pull out predictions and reformat output
X_pred_BUMMER <- BUMMER$X_pred
BUMMER$mu <- apply(X_pred_BUMMER, 1, mean)
BUMMER$sd <- apply(X_pred_BUMMER, 1, sd)
BUMMER$X_pred <- NULL

out = rbind(data.frame(WA, method='WA'), 
            data.frame(MAT, method='MAT'),
            data.frame(MLRC, method='MLRC'),
            data.frame(RF, method='RF'),
            data.frame(BUMMER, method='BUMMER'))

ggplot(data=out, aes(x=observations, y=mu, color=method)) + 
  geom_abline(intercept=0, slope=1) + 
  geom_point() + 
  xlab('Observed') +
  ylab('Predicted') +
  theme_bw()
# ggsave('figures/model_vs_data.pdf')

ggplot(data=out, aes(x=observations, y=mu, color=method)) + 
  geom_abline(intercept=0, slope=1) + 
  geom_point() + 
  geom_smooth(method='lm',formula=y~x) +
  xlab('Observed') +
  ylab('Predicted') +
  theme_bw()
# ggsave('figures/model_vs_data_best_fit_line.pdf')


ggplot(data=out) + 
  geom_abline(intercept=0, slope=1) + 
  geom_point(aes(x=observations, y=mu, color=method)) + 
    geom_pointrange(aes(x=observations, y=mu, ymin=mu-2*sd, ymax=mu+2*sd, color=method)) +
  xlab('Observed') +
  ylab('Predicted') +
  theme_bw()
# ggsave('figures/model_vs_data_best_uncertainty.pdf')

## predictive scores

## MSPE
g1 <- ggplot(data=out) + 
  geom_violin(aes(x=method, y=sqrt(MSPE), fill=method)) +
  stat_summary(aes(x=method, y=sqrt(MSPE), fill=method),
               fun.y=median, geom="point") +
  ylab("RMSPE") +
  theme_bw()

## MAE
g2 <- ggplot(data=out) + 
  geom_violin(aes(x=method, y=MAE, fill=method)) +
  stat_summary(aes(x=method, y=MAE, fill=method),
               fun.y=median, geom="point") +
  theme_bw()

## CRPS
g3 <- ggplot(data=out) + 
  geom_violin(aes(x=method, y=CRPS, fill=method)) +
    stat_summary(aes(x=method, y=CRPS, fill=method), 
                 fun.y=median, geom="point") +
  theme_bw()
multiplot(g1, g2, g3, cols=1)
```



```{r}
library(rioja)
nboot <- 100
N <- dim(y)[1]
boot_MA <- matrix(0, N, nboot)

## drop rare taxa
drop_idx <- which((apply(y, 2, sum) / sum(y)) < 0.01)
y <- y[, -drop_idx]
y_prop <- counts2proportions(y[1:500, ])
for (i in 1:nboot) {
  modMAT <- rioja::MAT(as.data.frame(y_prop), X[1:500], k=5, lean=TRUE)
  boot_MA[, i] <- predict(modMAT, as.data.frame(y_prop), k=5, sse=TRUE, n.boot=1)$fit[, 1]
  
  
  
}
```